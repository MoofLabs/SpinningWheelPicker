<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Interactive spinning wheel for random selection. Built with vanilla JavaScript and HTML5 Canvas." />
  <meta name="theme-color" content="#7c3aed" />
  <title>Spinning Wheel Picker - Random Name Selector</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json" />
  
  <!-- iOS specific -->
  <link rel="apple-touch-icon" href="icons/icon-180.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  
  <style>
    :root {
      --bg1: #6b21a8;
      --bg2: #ec4899;
      --card-bg: #fff;
    }
    html,body { height:100%; margin:0; font-family:Arial, sans-serif; }
    body {
      background:linear-gradient(135deg,var(--bg1),var(--bg2));
      display:flex; align-items:center; justify-content:center; padding:20px;
    }
    .card {
      background:var(--card-bg); border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.2);
      padding:24px; max-width:760px; width:100%;
    }
    h1 { text-align:center; margin:0 0 16px 0; }
    label { display:block; font-weight:600; margin-bottom:6px; }
    input[type="number"], input[type="text"] {
      width:100%; padding:10px; border-radius:8px; border:2px solid #e5e7eb; 
      margin-bottom:10px; box-sizing:border-box; font-size:16px;
    }
    input:focus { border-color: #7c3aed; outline:none; }
    .btn { 
      display:inline-block; padding:10px 18px; border-radius:8px; border:none; 
      cursor:pointer; font-weight:700; font-size:14px; 
    }
    .btn:hover { opacity:0.9; }
    .btn-primary { background:#7c3aed; color:white; }
    .btn-green { background:#16a34a; color:white; }
    .btn-gray { background:#4b5563; color:white; }
    .btn-mute { background:#f59e0b; color:white; padding:8px 12px; font-size:12px; margin-left:8px; }
    .winner { 
      background:#fbbf24; padding:12px 18px; border-radius:10px; 
      font-weight:800; font-size:18px; margin-top:12px; display:inline-block; 
    }
    .names-container {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 15px;
      padding-right: 5px;
    }
  </style>
</head>
<body>
  <div class="card" id="app"></div>
  <script>
  (function(){
    const app=document.getElementById('app');
    let numSegments='', names=[], customColors=[], isConfiguring=true, isSpinning=false, rotation=0, winner=null;
    let animationId=null, velocity=0, isStopping=false, stopStartTime=null, initialStopVelocity=0;
    let canvas, ctx, canvasSize=500;
    let isMuted=false, lastSegmentIndex=-1;
    let audioCtx=null;
    let openColorPicker=-1; // Track which segment's color picker is open
    const COLORS=['#FF6B6B','#4ECDC4','#45B7D1','#FFA07A','#98D8C8','#F7DC6F','#BB8FCE','#85C1E2'];
    const COLOR_PALETTE=['#E74C3C','#3498DB','#2ECC71','#F39C12','#9B59B6','#1ABC9C','#E67E22','#34495E'];

    // Initialize audio context once
    function getAudioContext() {
      if(!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      // Resume if suspended (browser autoplay policy)
      if(audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      return audioCtx;
    }

    // Sound functions using Web Audio API
    function playTick() {
      if(isMuted) return;
      const ctx = getAudioContext();
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      
      oscillator.frequency.value = 600;
      gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
      
      oscillator.start();
      oscillator.stop(ctx.currentTime + 0.05);
    }

    function playStop() {
      if(isMuted) return;
      const ctx = getAudioContext();
      [500, 400].forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = freq;
        gain.gain.value = 0.1;
        osc.start(ctx.currentTime + i * 0.1);
        osc.stop(ctx.currentTime + i * 0.1 + 0.1);
      });
    }

    function playWinner() {
      if(isMuted) return;
      const ctx = getAudioContext();
      [523, 659, 784, 1047].forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.2, ctx.currentTime + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.4);
        osc.start(ctx.currentTime + i * 0.15);
        osc.stop(ctx.currentTime + i * 0.15 + 0.4);
      });
    }

    function checkSegmentCrossing() {
      if(!isSpinning && !isStopping) return;
      const segAngleDeg = 360 / names.length;
      const normalizedRotation = ((rotation % 360) + 360) % 360;
      const pointerDeg = 270;
      const relative = ((pointerDeg - normalizedRotation) + 360) % 360;
      const currentSegment = Math.floor(relative / segAngleDeg) % names.length;
      
      if(currentSegment !== lastSegmentIndex) {
        lastSegmentIndex = currentSegment;
        playTick();
      }
    }

    function render(){
      app.innerHTML='';
      if(names.length===0)return renderNumSegments();
      if(isConfiguring)return renderNamesConfig();
      renderWheelUI();
    }

    function renderNumSegments(){
      app.innerHTML='<h1>Spinning Wheel Picker</h1><label>How many segments? (2-20)</label><input id="numSegmentsInput" type="number" min="2" max="20" placeholder="Enter a number" /><button id="numNext" class="btn btn-primary">Next</button>';
      const input=document.getElementById('numSegmentsInput');
      input.addEventListener('keydown',e=>{if(e.key==='Enter')document.getElementById('numNext').click();});
      document.getElementById('numNext').onclick=()=>{
        const n=parseInt(input.value);
        if(!Number.isInteger(n)||n<2||n>20)return alert('Please enter a number between 2 and 20');
        names=Array(n).fill(''); customColors=Array(n).fill(null); isConfiguring=true; render();
      };
    }

    function renderNamesConfig(){
      const rows=names.map((nm,i)=>{
        const selectedColor = customColors[i];
        const colorDisplay = selectedColor ? `<div style="width:28px;height:28px;background:${selectedColor};border-radius:4px;border:2px solid #333;"></div>` : '<div style="width:28px;height:28px;background:#ddd;border-radius:4px;border:2px solid #999;"></div>';
        
        const colorPalette = `<div id="colorPicker${i}" style="display:none;gap:6px;padding:8px;background:#f3f4f6;border-radius:8px;margin-top:6px;">
          ${COLOR_PALETTE.map(color=>`<div style="width:32px;height:32px;background:${color};border-radius:6px;cursor:pointer;border:2px solid ${customColors[i]===color?'#000':'#ddd'};transition:transform 0.2s;" data-idx="${i}" data-color="${color}" class="color-swatch"></div>`).join('')}
        </div>`;
        
        return `<div style="margin-bottom:16px;">
          <label>Segment ${i+1}</label>
          <div style="display:flex;gap:8px;align-items:center;">
            <input data-idx="${i}" class="name-input" type="text" value="${nm}" placeholder="Name ${i+1}" style="flex:1;" />
            <button class="color-btn" data-idx="${i}" style="padding:6px 12px;background:#7c3aed;color:white;border:none;border-radius:6px;cursor:pointer;display:flex;align-items:center;gap:6px;font-size:13px;font-weight:600;">
              ${colorDisplay}
              <span class="color-btn-icon">ðŸŽ¨</span>
            </button>
          </div>
          ${colorPalette}
        </div>`;
      }).join('');
      app.innerHTML=`<h1>Enter Names</h1><div class="names-container">${rows}</div><button id="createWheel" class="btn btn-primary">Create Wheel</button><button id="backBtn" class="btn btn-gray">Back</button>`;
      
      const inputs=document.querySelectorAll('.name-input');
      inputs.forEach(el=>{el.oninput=e=>names[+e.target.dataset.idx]=e.target.value.trim();});
      
      const colorBtns=document.querySelectorAll('.color-btn');
      colorBtns.forEach(el=>{
        el.onclick=(e)=>{
          e.preventDefault();
          const idx=+el.dataset.idx;
          const picker = document.getElementById(`colorPicker${idx}`);
          const icon = el.querySelector('.color-btn-icon');
          const isOpen = picker.style.display === 'flex';
          
          // Close all other pickers
          document.querySelectorAll('[id^="colorPicker"]').forEach(p => {
            if(p !== picker) {
              p.style.display = 'none';
            }
          });
          document.querySelectorAll('.color-btn-icon').forEach(ic => {
            if(ic !== icon) {
              ic.textContent = 'ðŸŽ¨';
            }
          });
          
          // Toggle this picker
          if(isOpen) {
            picker.style.display = 'none';
            icon.textContent = 'ðŸŽ¨';
          } else {
            picker.style.display = 'flex';
            icon.textContent = 'âœ•';
          }
        };
      });
      
      const colorSwatches=document.querySelectorAll('.color-swatch');
      colorSwatches.forEach(el=>{
        el.onclick=()=>{
          const idx=+el.dataset.idx, color=el.dataset.color;
          customColors[idx]=color;
          
          // Update the color display in the button without full re-render
          const btn = document.querySelector(`.color-btn[data-idx="${idx}"]`);
          const colorDisplay = btn.querySelector('div');
          colorDisplay.style.background = color;
          colorDisplay.style.border = '2px solid #333';
          
          // Close the picker
          const picker = document.getElementById(`colorPicker${idx}`);
          picker.style.display = 'none';
          btn.querySelector('.color-btn-icon').textContent = 'ðŸŽ¨';
          
          // Update all swatches in this picker to show new selection
          picker.querySelectorAll('.color-swatch').forEach(swatch => {
            if(swatch.dataset.color === color) {
              swatch.style.border = '2px solid #000';
            } else {
              swatch.style.border = '2px solid #ddd';
            }
          });
        };
      });
      
      inputs.forEach((el, index)=>{
        el.addEventListener('keydown',e=>{
          if(e.key==='Enter'){
            e.preventDefault();
            const nextIndex = index + 1;
            if(nextIndex < inputs.length) {
              inputs[nextIndex].focus();
              inputs[nextIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              if([...inputs].every(inp=>inp.value.trim())) {
                document.getElementById('createWheel').click();
              } else {
                const firstEmpty = [...inputs].find(inp => !inp.value.trim());
                if(firstEmpty) {
                  firstEmpty.focus();
                  firstEmpty.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
              }
            }
          }
        });
        el.addEventListener('focus', ()=>{
          el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });
      });
      document.getElementById('createWheel').onclick=()=>{
        if(names.some(n=>!n.trim()))return alert('Please fill all names');
        isConfiguring=false; winner=null; openColorPicker=-1; initCanvas(); render();
      };
      document.getElementById('backBtn').onclick=()=>{names=[];customColors=[];openColorPicker=-1;render();};
    }

    function renderWheelUI(){
      app.innerHTML=`<div style="text-align:center">
        <canvas id="wheelCanvas" width="${canvasSize}" height="${canvasSize}" style="max-width:100%"></canvas>
        <div id="winnerSpot"></div>
        <div style="margin-top:10px">
          <button id="toggleSpin" class="btn btn-green">${isSpinning?'Stop Spinning':'Start Spinning'}</button> 
          <button id="reconfigure" class="btn btn-gray">Reconfigure</button>
          <button id="muteBtn" class="btn btn-mute">${isMuted?'ðŸ”‡ Unmute':'ðŸ”Š Mute'}</button>
        </div>
        <div class="muted" style="margin-top:8px">Press SPACE to start/stop</div>
      </div>`;
      canvas=document.getElementById('wheelCanvas'); ctx=canvas.getContext('2d'); drawWheel();
      document.getElementById('toggleSpin').onclick=()=>{toggleSpin(); updateButton();};
      document.getElementById('reconfigure').onclick=()=>{cancelAnim(); names=[];customColors=[];render();};
      document.getElementById('muteBtn').onclick=()=>{isMuted=!isMuted; updateButton();};
      window.onkeydown = (e) => {
        if (e.code === 'Space' && !isConfiguring) {
          e.preventDefault();
          toggleSpin();
          updateButton();
        }
      };
    }

    function updateButton(){
      const btn=document.getElementById('toggleSpin');
      if(btn) btn.textContent=isSpinning?'Stop Spinning':'Start Spinning';
      const muteBtn=document.getElementById('muteBtn');
      if(muteBtn) muteBtn.textContent=isMuted?'ðŸ”‡ Unmute':'ðŸ”Š Mute';
    }

    function initCanvas(){canvasSize=Math.min(500,window.innerWidth-60);}

    function drawWheel(){
      const cw=canvas.width=canvasSize,ch=canvas.height=canvasSize,cx=cw/2,cy=ch/2,r=Math.min(cx,cy)-10;
      ctx.clearRect(0,0,cw,ch); ctx.save(); ctx.translate(cx,cy); ctx.rotate((rotation*Math.PI)/180);
      const segAngle=2*Math.PI/names.length;
      
      // Dynamic text size based on number of segments - maximized for readability
      let fontSize;
      if(names.length <= 4) fontSize = Math.floor(r*0.15);
      else if(names.length <= 6) fontSize = Math.floor(r*0.12);
      else if(names.length <= 8) fontSize = Math.floor(r*0.10);
      else if(names.length <= 12) fontSize = Math.floor(r*0.08);
      else fontSize = Math.floor(r*0.065);
      
      // Build final color array ensuring uniqueness
      const finalColors = [];
      const usedColors = new Set();
      
      // First pass: assign custom colors and track them
      names.forEach((name, i) => {
        if(customColors[i]) {
          finalColors[i] = customColors[i];
          usedColors.add(customColors[i]);
        } else {
          finalColors[i] = null;
        }
      });
      
      // Second pass: assign unused colors to segments without custom colors
      const allColors = [...COLOR_PALETTE, ...COLORS];
      let colorIndex = 0;
      
      names.forEach((name, i) => {
        if(!finalColors[i]) {
          // Find next unused color
          let foundColor = null;
          for(let j = 0; j < allColors.length * 2; j++) {
            const testColor = allColors[(colorIndex + j) % allColors.length];
            if(!usedColors.has(testColor)) {
              foundColor = testColor;
              colorIndex = (colorIndex + j + 1) % allColors.length;
              break;
            }
          }
          // If all colors are used, just cycle through
          if(!foundColor) {
            foundColor = allColors[i % allColors.length];
          }
          finalColors[i] = foundColor;
          usedColors.add(foundColor);
        }
      });
      
      names.forEach((name,i)=>{
        const start=i*segAngle,end=start+segAngle;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,r,start,end); ctx.closePath();
        
        ctx.fillStyle=finalColors[i]; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.stroke();
        ctx.save(); ctx.rotate(start+segAngle/2); ctx.textAlign='center'; ctx.fillStyle='#fff';
        ctx.font=`bold ${fontSize}px Arial`; ctx.translate(r*0.6,0);
        wrapText(ctx,name,0,0,r*0.3); ctx.restore();
      }); 
      ctx.restore();
      
      // Draw pointer outside the wheel (Wheel of Fortune style)
      const pointerSize = 20;
      ctx.beginPath(); 
      ctx.moveTo(cx, cy - r + pointerSize*0.3); 
      ctx.lineTo(cx - pointerSize*0.6, cy - r - pointerSize); 
      ctx.lineTo(cx + pointerSize*0.6, cy - r - pointerSize); 
      ctx.closePath(); 
      ctx.fillStyle='#333'; 
      ctx.fill();
      ctx.strokeStyle='#fff';
      ctx.lineWidth=2;
      ctx.stroke();
    }

    function wrapText(ctx,text,x,y,maxWidth){const words=text.split(' ');let line='',lh=parseInt(ctx.font)+2,offsetY=0;for(let n=0;n<words.length;n++){const test=line+words[n]+' ';if(ctx.measureText(test).width>maxWidth&&n>0){ctx.fillText(line,x,y+offsetY);line=words[n]+' ';offsetY+=lh;}else line=test;}ctx.fillText(line.trim(),x,y+offsetY);}

    function toggleSpin(){if(isSpinning)stopSpin();else startSpin();}

    function startSpin(){
      if(isSpinning)return;
      isSpinning=true;
      updateButton();
      velocity=20+Math.random()*20;
      document.getElementById('winnerSpot').innerHTML='';
      lastSegmentIndex=-1;
      isStopping=false;
      // Resume audio context on user interaction
      if(audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      animationId=requestAnimationFrame(animate);
    }

    function stopSpin(){
      if(!isSpinning){isStopping=true;stopStartTime=Date.now();initialStopVelocity=velocity;return;}
      isSpinning=false;
      updateButton();
      playStop();
      isStopping=true;
      stopStartTime=Date.now();
      initialStopVelocity=velocity;
    }

    function animate(){
      if(isStopping){
        const t=(Date.now()-stopStartTime)/1000,d=4;
        if(t<d){
          const p=t/d,eased=1-Math.pow(1-p,3);
          velocity=initialStopVelocity*(1-eased);
          rotation+=velocity*0.5; 
          checkSegmentCrossing();
          drawWheel(); 
          animationId=requestAnimationFrame(animate);
        }else{
          isStopping=false; velocity=0; cancelAnim(); pickWinner();
        }
      }else if(isSpinning){
        rotation+=velocity*0.5; 
        checkSegmentCrossing();
        drawWheel(); 
        animationId=requestAnimationFrame(animate);
      }
    }

    function cancelAnim(){if(animationId){cancelAnimationFrame(animationId);animationId=null;}}

    function pickWinner(){
      const segAngleDeg = 360 / names.length;
      const normalizedRotation = ((rotation % 360) + 360) % 360;
      const pointerDeg = 270;
      const relative = ((pointerDeg - normalizedRotation) + 360) % 360;
      const index = Math.floor(relative / segAngleDeg) % names.length;
      winner = names[index];
      document.getElementById('winnerSpot').innerHTML=`<div class="winner">ðŸŽ‰ Winner: ${winner}! ðŸŽ‰</div>`;
      playWinner();
    }

    render();
  })();
  </script>
  
  <!-- Register Service Worker -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js')
          .then(reg => console.log('Service Worker registered'))
          .catch(err => console.log('Service Worker registration failed:', err));
      });
    }
  </script>
</body>
</html>
